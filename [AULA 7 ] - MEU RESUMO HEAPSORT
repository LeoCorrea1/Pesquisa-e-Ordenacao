
9) HEAPSORT (método baseado na dinâmica de árvores binárias, contudo em lista)
    - Heapmáximo: garantir que raiz da subarvore seja maior ou igual que seus filhos. Se isso não ocorrer, fazer as trocas
        filhoEsquerda = posicaoRaiz * 2
        filhoDireita = posicaoRaiz * 2 + 1
    - Troca do primeiro com o último e diminui uma posição o lista (fim)

    ATENÇÃO: o lista deve começar na posição 1

    Teste para filho esquerda 
        -> if (lista[raiz] < lista[raiz * 2]) { troca }
    Teste para o filho da direita (antes de testar, é preciso ter certeza que o filho exista)
        -> if (raiz * 2 + 1 < n && lista[raiz] < lista[raiz * 2 + 1]) { troca }


  1   2  3  4  5   6  7     
  15  7  4  8  12  1  3   

Raiz	    Filho esquerdo	 Filho direito
1 → 15    	2 → 7	           3 → 4
2 → 7	      4 → 8	           5 → 12
3 → 4	      6 → 1	           7 → 3

 1   2   3  4  5   6  7 
 15  7   4   8   12  1   3   - Raiz 1 (15) → filhos 7 e 4 → troca com menor filho 4
 4   7   15  8   12  1   3   - Raiz 3 (15) → filhos 1 e 3 → troca com menor filho 1
 4   7   1   8   12  15  3   - Raiz 3 (1) → filhos 15 e 3 → troca com menor filho 3
 4   7   3   8   12  15  1   - Raiz 1 (4) → filhos 7 e 3 → troca com menor filho 3
 3   7   4   8   12  15  1   - Raiz 1 (3) → filhos 7 e 4 → já menor → não troca
 3   7   4   8   12  15  1   - Heap mínimo construído

 1   7   4   8   12  15  3   - Troca raiz 3 com último do heap (posição 7)
 1   7   4   8   12  15  3   - Raiz 1 (1) → filhos 7 e 4 → já menor → não troca
 1   3   4   8   12  15  7   - Troca raiz 7 com último do heap (posição 6)
 1   3   4   8   12  15  7   - Raiz 1 (1) → filhos 3 e 4 → já menor → não troca
 1   3   4   8   12  15  7   - Troca raiz 1 com último do heap (posição 5)
 1   3   4   8   12  15  7   - Raiz 1 (1) → filhos 3 e 4 → já menor → não troca
 1   3   4   7   8   12  15   - Troca raiz 1 com último do heap (posição 4)
 1   3   4   7   8   12  15   - Raiz 1 (1) → filhos 3 → já menor → não troca
 1   3   4   7   8   12  15   - Troca raiz 1 com último do heap (posição 3)
 1   3   4   7   8   12  15   - Heap final ordenado


     


