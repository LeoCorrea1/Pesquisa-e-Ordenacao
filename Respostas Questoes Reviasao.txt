# Avalia√ß√£o - Pesquisa e Ordena√ß√£o

## 1) Por que devemos ter sistemas com estruturas de dados ordenadas?
Porque dados ordenados permitem buscas mais r√°pidas (ex: pesquisa bin√°ria), economizam tempo de processamento, facilitam an√°lises, relat√≥rios e integra√ß√£o entre sistemas.

Al√©m disso, v√°rias estruturas avan√ßadas (√°rvores, √≠ndices de banco, tabelas hash balanceadas) dependem de ordena√ß√£o para funcionar eficientemente.

---

## 2) Os sistemas de banco de dados possuem mecanismos de ordena√ß√£o autom√°tica?
**Sim.**

Os √≠ndices em SGBDs (B-trees, B+trees, hash indexes) s√£o estruturas que mant√™m os dados automaticamente ordenados para agilizar buscas, filtragens e ordena√ß√µes em consultas.

---

## 3) Qual o melhor m√©todo de ordena√ß√£o?
Depende do contexto:

- Para pequenos conjuntos de dados: **Insertion Sort** √© simples e eficiente.
- Para grandes conjuntos: **Merge Sort** e **Quick Sort** (O(n log n)) s√£o melhores.
- Para estabilidade garantida: **Merge Sort**.
- Para velocidade pr√°tica na m√©dia: **Quick Sort**.

üëâ N√£o existe um √∫nico "melhor" m√©todo, mas sim o mais adequado ao caso.

---

## 4) Em que tamanho de estrutura, um ou outro m√©todo j√° come√ßa a fazer diferen√ßa?
- Em listas pequenas (at√© algumas centenas de elementos), algoritmos **O(n¬≤)** (como inser√ß√£o) ainda funcionam bem.
- Em listas maiores (milhares ou milh√µes de elementos), a diferen√ßa fica clara:
  - **O(n¬≤)** fica invi√°vel.
  - **O(n log n)** se torna obrigat√≥rio.

---

## 5) Nos benchmarks realizados nos algoritmos de ordena√ß√£o, quais s√£o as vari√°veis de acompanhamento?
- N√∫mero de compara√ß√µes.
- N√∫mero de trocas/movimenta√ß√µes.
- Tempo de execu√ß√£o.
- Quantidade de elementos processados.

---

## 6) O que √© complexidade de um algoritmo?
√â o **esfor√ßo computacional** necess√°rio para executar o algoritmo.

Medido em **tempo** (compara√ß√µes, trocas) e **espa√ßo** (mem√≥ria adicional).

Representado em **Nota√ß√£o Big-O**:
- O(1): constante.
- O(log n): logar√≠tmica.
- O(n): linear.
- O(n¬≤): quadr√°tica.
- O(n^x): polinomial.
- O(n!): fatorial (alt√≠ssimo custo).

---

## 7) Quais mecanismos otimizam a ordena√ß√£o em alguns m√©todos?
1. **An√°lise a dist√¢ncia (gap)** ‚Üí pr√©-organiza a lista:
   - Pente (Comb Sort), Shell Sort, Quick Sort.
2. **Divis√£o recursiva da estrutura** ‚Üí divide e conquista:
   - Quick Sort, Merge Sort.

---

## 8) Os m√©todos que utilizam a dist√¢ncia para pr√©-organizar as estruturas s√£o est√°veis ou inst√°veis? Por qu√™?
Geralmente **inst√°veis**, porque ao usar saltos (gaps), elementos iguais podem trocar a ordem relativa entre si.

Exemplo: no **Shell Sort**, dois valores iguais podem ser reposicionados em ordens diferentes.

---

## 9) Diferen√ßas entre Quick e Merge Sort:
- **Merge Sort**:
  - Divide sempre **ao meio**.
  - Ordena na **volta da recurs√£o**, usando intercala√ß√£o.
  - **Est√°vel**.
  - Requer **mem√≥ria extra**.

- **Quick Sort**:
  - Divide usando um **piv√¥**.
  - Ordena o **piv√¥ em cada chamada**.
  - Geralmente **inst√°vel**.
  - Mais r√°pido na pr√°tica, mas pior caso pode ser **O(n¬≤)**.

---

## 10) O que Quick e Merge t√™m em comum?
- S√£o **algoritmos recursivos**.
- T√™m comportamento de **√°rvore bin√°ria** (cada divis√£o gera 2 ramos).
- A ordena√ß√£o acontece na **volta do empilhamento da recurs√£o**.
- Ambos t√™m complexidade m√©dia de **O(n log n)**.
